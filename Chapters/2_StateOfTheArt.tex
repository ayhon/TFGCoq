\chapter{State of the art}
\label{cap:state-of-the-art}

% Capítulo 2: ESTADO DEL ARTE
% 2.1 Blockchain
% 2.1.1 Qué es
% 2.1.2 Ethereum y los contratos inteligente
% 2.1.3 EVM: aquí metería todas las explicaciones de bajo nivel sobre la ejecución de EVM y el ejemplo de la ejecución de los dos smart contracts (sin centrarme todavía en su equivalencia o no)
% 2.1.4 GASOL, optimización de smart contracts y su equivalencia. Ver cómo los dos smart contracts anteriores son equivalentes si se verifican las restricciones necesarias, que es lo que generaría tu resolutor
% 2.2 Restricciones y algoritmos para comprobarlas/generar el cierre transitivo
% 2.3 The Coq Proof Assistant
% 2.3.1 Funciones
% 2.3.2 Demostraciones
% 2.3.3 Curry/Howard

\section{Blockchain}

A block-chain implements a distributed ledger, a database of transactions
between entities which is not hosted by any central authority but shared
among multiple computers in a network. The name comes from the mechanism
in which these transactions are stored: groups of transactions called
``blocks'' are linked together forming a ``chain''. Once a block of 
transactions has been recorded in the block-chain, no further changes can
be applied to it without needing to change all subsequent blocks, which in
real world scenarios is made to be unfeasible, thus ensuring the immutability
and transparency of the data.

% Talk about proof of work.

Blockchain technology has diverse applications, the most famous one being
as a form of currency. One of these use cases of particular interest is 
implementing smart contracts. Smart contracts are self-executing contracts
whose terms are directly expressed as code. They run on a blockchain 
network and automatically execute actions when predefined conditions are
met, without the need to rely on a trusted intermediary since their
execution is verified by the decentralized network. The usage of smart
contracts has enabled the development of new and innovative decentralized
applications (DApps).

\subsection{The Ethereum Virtual Machine}

Ethereum is a prominent blockchain platform which stands out for its robust
support for smart contracts through the Ethereum Virtual Machine (EVM). The
EVM is a runtime environment that enables the execution of code written in
Ethereum's native language, Solidity. Solidity code is compiled into EVM 
bytecode, which is composed of instructions operating on a stack-based 
virtual machine. Each operation performed in the EVM incurs a cost measured 
in gas, Ethereum's unit of computational cost. This cost is covered by the 
user interacting with the smart contract and is payed in the Ethereum 
blockchain's native currency, of the same name. This serves as a mechanism 
to prioritize and meter the execution of code in the network, which ensures 
that the network remains efficient and secure, by encouraging developers to 
be mindful of their use of resources. This contributes to preventing spam 
attacks and resource abuse, ensuring the stability and sustainability of the 
Ethereum ecosystem.

As stated in Ethereum's Yellow Paper \cite{wood2014ethereum}, the EVM is a 
stack-based machine virtual machine, with added access to a system of persistent 
storage commonly referred to as memory. The word size of the machine is 256-bits.
When a smart contract is to be executed, a new stack of up-to 1024 words is 
created for its execution, which will be destroyed after the execution has 
completed. Therefore, for a change to be persisted between executions it needs
to be recorded in memory.

EVM instructions modify the state of the EVM in two main ways:
\begin{itemize}
    \item Manipulating the values in the stack. \\
    For example, consider the \textcolor{red}{\texttt{ADD}} instruction which
    pushes to the top of the stack the addition of its first two elements.
    When simulating the execution of a program, this will be represented by
    showing the state of the stack before and after the execution of the 
    instruction. 
    \begin{Verbatim}[commandchars=\\\{\}]
    [x0,x1] 
     ↓ \textcolor{red}{ADD}
    [x0+x1]
    \end{Verbatim}

    \item Producing an effect. \\
    An \emph{effect} is any change which can be observed by an external process.
    Since the memory storage is persistent, writing to memory is an effect.
    For example, the \textcolor{red}{\texttt{MSTORE}} instruction pops the
    first two elements of the stack and stores the value of the second
    element in the memory offset referenced by the first element. The addressing
    in EVM is done per byte, and since the word-size is $256$, consecutive addresses
    in memory differ by $32$. When simulating the execution of a program, we 
    represent effects, if present, by putting them in parenthesis next to the state 
    of the stack.
    \begin{Verbatim}[commandchars=\\\{\}]
    [x0,x1]
     ↓ \textcolor{red}{MSTORE}
    []   \textcolor{teal}{(MEM[x0] = x1)}
    \end{Verbatim}
\end{itemize}

The EVM defines much more instructions. For the purposes of this chapter, only a few
more will be described.
\begin{itemize}
    \item \textcolor{red}{\texttt{SWAP1}} exchanges the top element in the stack with the
    second element bellow it.
    \begin{Verbatim}[commandchars=\\\{\}]
    [x0,x1]
     ↓ \textcolor{red}{SWAP1}
    [x1,x0]
    \end{Verbatim}

    \item \textcolor{red}{\texttt{SWAP2} } exchanges the top element in the stack with the
    second element bellow it.
    \begin{Verbatim}[commandchars=\\\{\}]
    [x0,x1,x2]
     ↓ \textcolor{red}{SWAP2}
    [x2,x1,x0]
    \end{Verbatim}

    \item \textcolor{red}{\texttt{SWAP3}} exchanges the top element in the stack with the
    third element bellow it.
    \begin{Verbatim}[commandchars=\\\{\}]
    [x0,x1,x2,x3]
     ↓ \textcolor{red}{SWAP3}
    [x3,x1,x2,x0]
    \end{Verbatim}

    \item \textcolor{red}{\texttt{POP}} discards the top element of the stack.
    \begin{Verbatim}[commandchars=\\\{\}]
    [x0] 
     ↓ \textcolor{red}{POP}
    []
    \end{Verbatim}
\end{itemize}


For instance, consider the foll %TODO: Redact

\begin{listing}[!ht]
{\color{red}
\begin{verbatim}
SWAP3 SWAP1 SWAP2 MSTORE SWAP1 SWAP2 ADD SWAP1 MSTORE
\end{verbatim}
}
\caption{EVM bytecode sequence 1}
\label{lst:evm-original}
\end{listing}

\begin{listing}[!ht]
{\color{red}
\begin{verbatim}
MSTORE MSTORE POP 
\end{verbatim}
}
\caption{EVM bytecode sequence 2}
\label{lst:evm-optimized}
\end{listing}

% TODO: Link 
Consider the execution of the first program (\ref{lst:evm-original}).

\begin{Verbatim}[commandchars=\\\{\}]
[x0,x1,x2,x3,x4,x5]
 ↓ \textcolor{red}{SWAP3}
[x3,x1,x2,x0,x4,x5]
 ↓ \textcolor{red}{SWAP1}
[x1,x3,x2,x0,x4,x5]
 ↓ \textcolor{red}{SWAP2}
[x2,x3,x1,x0,x4,x5]
 ↓ \textcolor{red}{MSTORE}
[x1,x0,x4,x5] \textcolor{teal}{(MEM[x2] = x3)}
 ↓ \textcolor{red}{SWAP1}
[x0,x1,x4,x5] \textcolor{teal}{(MEM[x2] = x3)}
 ↓ \textcolor{red}{SWAP2}
[x4,x1,x0,x5] \textcolor{teal}{(MEM[x2] = x3)}
 ↓ \textcolor{red}{ADD}
[x4+x1,x0,x5] \textcolor{teal}{(MEM[x2] = x3)}
 ↓ \textcolor{red}{SWAP1}
[x0,x4+x1,x5] \textcolor{teal}{(MEM[x2] = x3)}
 ↓ \textcolor{red}{MSTORE}
[x5]          \textcolor{teal}{(MEM[x2] = x3; MEM[x0] = x4+x1)}
\end{Verbatim}

Finally, consider the execution of the second program (\ref{lst:evm-optimized})

\begin{Verbatim}[commandchars=\\\{\}]
[x0,x1,x2,x3,x4,x5]
 ↓ \textcolor{red}{MSTORE}
[x2,x3,x4,x5] \textcolor{teal}{(MEM[x0] = x1)}
 ↓ \textcolor{red}{MSTORE}
[x4,x5]       \textcolor{teal}{(MEM[x0] = x1; MEM[x2] = x3)}
 ↓ \textcolor{red}{POP}
[x5]          \textcolor{teal}{(MEM[x0] = x1; MEM[x2] = x3)}
\end{Verbatim}

\subsection{Optimization of smart contracts}

The \verb|GASOL| project implements a superoptimizer for EVM bytecode. Superoptimization 
is a compilation technique that searches, for a given jump-free sequence of 
instructions, a semantically equivalent sequence of instructions which is optimal
by some metric, like memory usage or execution cost. Since the superoptimizer 
requires these sequences of instructions to not have bifurcations, to optimize a
whole program it first extracts all the sequences of instructions which do not perform
jumps and optimizes those separately before reassembling them back together. 
In doing so, it remembers which conditions triggered those jumps so it can gain more
information on which states of the program are possible for each section.

The \verb|FORVES| project, although not dependent on \verb|GASOL|, was originally started
to certify that its optimizations didn't modify the semantic of the given programs. That is
why \verb|FORVES| inherited the requirement that the sequences of instructions be jump-free.
The currently implemented \verb|FORVES| verifier has been thoroughly tested on outputs of
\verb|GASOL|, but some optimizations prove harder to verify than others. 

For instance, the previously presented listings \ref{lst:evm-original} and \ref{lst:evm-optimized}
are unoptimized and optimized versions of the same jump-free sequence of EVM bytecode 
instructions. While the end result of the stacks are equivalent for both executions, we can't
ensure that the effects they produce are equivalent. For starters, we cannot ensure that the 
memory accesses can be commuted. After all, if \verb|x0| $=$ \verb|x2| $= 0$ then after the 
first program we'd have {\textcolor{teal}{\texttt{MEM[0]~=~x4+x1}}} but after the second we'd have 
{\textcolor{teal}{\texttt{MEM[0]~=~x3}}}, which need not be the same if \verb|x3| $\ne$ \verb|x4+x1|.
Furthermore, we'd need that \verb|x4+x1| $=$ \verb|x1|, which is only possible if \verb|x4| $= 0$.

However, some of these conditions may be fulfilled if we consider the contextual information.
For example, consider the following contextual information, a list of added constraints to the
previous variables.

\begin{itemize}
    \item \verb|x4| $=$ \verb|x5|
    \item \verb|x5| $=$ 0
    \item \verb|x0| $\ge$ \verb|x2| $+ 128$
\end{itemize}

From the last constraint we can derive that the memory accesses to the offsets
referenced by \verb|x0| and \verb|x2| are disjoint, since the word size of the EVM is of 32 bytes and 
$32 < 128$. Therefore we can reorder both writes while preserving the semantics of the code.
Finally, from the first two constraints we can derive that \verb|x4| $= 0$ which ensures that \verb|x4| $+$ 
\verb|x1| is in fact equivalent to \verb|x1|.

This example motivates the necessity of taking contextual information into account when verifying
optimizations.

\section{Octagonal constraints}
The constraints we are interested on can be reduced to a special type of constraint called
octagonal constraints. Octagonal constraints are constraints of the type ${\pm x \pm y \le d}$ 
or $\pm x \le d$ where $x$ and $y$ are integer variables. In general we assume that $d$ is an
integer, since otherwise we could exploit the fact that the left hand side of both types of
constraints result in integers to derive a more strict inequality using $\lfloor d \rfloor$
instead. This new constraint $\pm x \pm y \le \lfloor d \rfloor$ is called the \emph{tightened}
constraint of $\pm x \pm y \le d$.

Octagonal constraints have been studied in depth in the literature. In particular, efficient
algorithms have been derived to compute the transitive closure of a set of constraints. The
transitive closure of a set of constraints $C$ is a set of constraints $C'$ where for every
pair of variables $x$ and $y$ defined in the constraints of $C$ we have a $d$ such that
the constraint $x + y \le d$ is in $C'$ and a $d'$ such that $x \le d'$ is in $C'$. Furthermore,
the choices of $d$ and $d'$ are the smallest possible such that they can still be derived from
the constraints in $C$.

In \cite{TransitiveClosure} an $O(n^3\log{n})$ algorithm is described to compute the tightened 
transitive closure of a set of octagonal constraints where $n$ is the number of integer variables. The 
same article cites \cite{HarveyStuckey} for providing an $O(n^4)$ algorithm which relies on the 
application of successive rules to iteratively construct the transitive closure.

\section{The Coq Proof Assistant}
\label{cap:coq-proof-assistant}

% TODO: Fill in with general info about Coq
From Coq's website\footnote{\url{https://coq.inria.fr/}}

\begin{quote}
    Coq is a formal proof management system. It provides a formal language to write mathematical
    definitions, executable algorithms and theorems together with an environment for semi-interactive
    development of machine-checked proofs. Typical applications include the certification of properties
    of programming languages, the formalization of mathematics, and teaching.
\end{quote}

Of the mentioned typical applications in this project we are most interested in 
the first, the ``certification of properties of programming languages''. In
particular we are interested in verifying that certain algorithms satisfy certain properties
that ensure they are implemented correctly and fulfill their purpose. The Coq proof assistant 
has been used extensively to verify a multitude of projects.

\begin{itemize}
    \item \verb|CompCert| \cite{CompCert}, 
    a certified compiler for the majority of the C language.
    
    \item \verb|Iris| \cite{Iris}, 
    a higher-order concurrent separation logic framework, used for reasoning about safety of concurrent programs, as the logic in logical relations, to reason about type-systems, data-abstraction, \dots. It has been used in other projects such as RustBelt \cite{RustBelt}.
    
    \item \verb|Fiat-Crypto| \cite{FiatCryptoSP19}, 
    a tool for cryptographic primitive code generation.
    
    \item \verb|ConCert| \cite{ConCert}, 
    a framework for smart contract verification in Coq.
    
    \item \verb|Cosette| \cite{Cosette}, 
    an automated prover for checking equivalences of SQL queries.
\end{itemize}

In essence, it's a tool for writing and verifying mathematical proofs and developing certified software.
To provide this functions, Coq provides a way of creating programs, functioning as a programming 
languages, and a way to develop proofs, functioning as a proof assistant.


\subsection{Coq as a functional programming language}
\label{sect:coq-programming-language}
\definecolor{outputbg}{rgb}{0.95,0.95,0.98}

Although, at its core, Coq is a typed functional programming language, we interact with this language
in a peculiar way. When you write a program in Coq you can think of it as having a conversation with the
language, where each statement is a question and its result is what Coq gives you as an answer. It is not
that different from writing your programs in a REPL in other languages. However, Coq  allows you to be
very creative with your questions. For example, the following command will prompt Coq to show the internal
representation of its grammar. Pay attention to the final dot. All Coq commands must end in a dot.

\begin{minted}{coq}
Print Grammar constr.
\end{minted}
\vspace{-\baselineskip*3/2}
\begin{minted}[bgcolor=outputbg]{coq}
Entry constr is
[ LEFTA
  [ "@"; global; univ_annot
  | term LEVEL "8" ] ]
and lconstr is
  ...
\end{minted}

At first this might come off as odd. Why would one need such a command? The answer is that, while in most
programming languages we regard the grammar as something static, Coq allows you to alter the way it parses
your definitions. Therefore, it is useful to know what Coq currently thinks the grammar looks like. 

However, these commands are not to what we refer to when we talk about Coq being a programming language.
The programming language inside Coq can be accessed through some special commands, such as 
\mintinline{coq}{Inductive} or \mintinline{coq}{Definition}.

\mintinline{coq}{Inductive} allows us to define data types. They work similarly to enumerations in other
languages. Consider, for example, the following definition of the booleans as a type containing two 
constructors, \mintinline{coq}{true} and \mintinline{coq}{false}.

\begin{minted}{coq}
Inductive bool := 
  | true
  | false.
\end{minted}

An inductive type defined in this way can have any number of constructors, including zero!

\begin{figure}[!ht]
\begin{minted}{coq}
Inductive void := .
\end{minted}
\label{lst:void}
\end{figure}

You can check for the type of a value with the \mintinline{coq}{Check} command.

\begin{minted}{coq}
Check false. 
\end{minted}
\vspace{-\baselineskip*3/2}
\begin{minted}[bgcolor=outputbg]{coq}
false
     : bool
\end{minted}

While the \mintinline{coq}{Inductive} command allows us to define types, \mintinline{coq}{Definition}
allows us to define values. This works in a similar way to general programming languages. The 
following statement assigns to the variable named \mintinline{coq}{my_true} the value 
\mintinline{coq}{true}.

\begin{minted}{coq}
Definition my_true := true.
\end{minted}

A function can be defined through the \mintinline{coq}{Definition} command by specifying its arguments on
the left side of the \mintinline{coq}{:=} symbol. The parenthesis around the arguments are only needed if you 
want to specify the argument's type, or if the type itself could not be inferred by Coq itself. For 
example we define the function \mintinline{coq}{always_true} which takes a boolean argument 
\mintinline{coq}{b} and always returns \mintinline{coq}{true}.

\begin{minted}{coq}
Definition always_true (b: bool) := true.
\end{minted}

To express the return type of a function we also use the \mintinline{coq}{:type} syntax, putting it 
right before the \mintinline{coq}{:=} symbol. The following line defines the identity function for
values of type \mintinline{coq}{bool}.

\begin{minted}{coq}
Definition bool_identity (b: bool) : bool := b.
\end{minted}

To the right side of the \mintinline{coq}{:=} symbol we can put any Coq expression. Technically, the 
language of expressions in Coq is called Gallina
% https://coq.inria.fr/doc/v8.9/refman/language/gallina-specification-language.html#:~:text=This%20chapter%20describes%20Gallina%2C%20the,%2C%20functions%2C%20predicates%20and%20sets.
but people usually refer to it as just Coq informally. Calling a function is an expression, and the syntax
used is the same as when defining one. To illustrate this we introduce the \mintinline{coq}{Compute}
command, which prompts Coq to evaluate an expression and show its result. 

\begin{minted}{coq}
Compute bool_identity true.
\end{minted}
\vspace{-\baselineskip*3/2}
\begin{minted}[bgcolor=outputbg]{coq}
= true
     : bool
\end{minted}

A useful construct of Gallina is that of the 
\mintinline{coq}{match _ with ... end} which lets us act differently depending on the way values were
constructed. This can be used, for example, to define the boolean \mintinline{coq}{notb} function,
which exchanges \mintinline{coq}{true} for \mintinline{coq}{false} and vice versa.

\begin{minted}{coq}
Definition notb b := match b with 
                     | true => false
                     | false => true
                     end.
\end{minted}

Observe that in this case we could omit the parenthesis in the argument definition, since Coq was
able to infer the type of \mintinline{coq}{b} from how it was used in the expression.

We can also create functions which return anonymous functions by using the \mintinline{coq}{fun} 
keyword. The arguments are specified with the same syntax as before, with the main difference being 
that now the \mintinline{coq}{=>} symbol is used to separate the arguments from the body, and not 
\mintinline{coq}{:=}. The types of functions use the \mintinline{coq}{->} symbol to separate the 
argument type from the return type. Consider the following function which implements a curried
version of the boolean and function.

\begin{minted}{coq}
Definition andb (b: bool) : bool -> bool :=
  fun b' => match b with 
            | true => b'
            | false => false
            end.
\end{minted}
\noindent As with most functional programming languages, functions in Coq can be curried, which means 
that they can be partially applied, providing only one argument and returning a function which takes 
the others. Therefore this type of definition is, in fact, unnecessary. We could have achieved the 
same result by having the function take both arguments \mintinline{coq}{b} and \mintinline{coq}{b'} 
directly.

When defining a new type with \mintinline{coq}{Inductive}, the constructors themselves can also take 
arguments. This works as the main way of storing values in Coq, similar to how records work in other
programming languages. For example, this is how we woudl define a named pair of two boolean values.

\begin{minted}{coq}
Inductive two_bools := my_bools (b b': bool).
\end{minted}

Notice that \mintinline{coq}{b'} is a valid identifier in Coq. While this is not unique to Coq (OCaml 
also has this feature), it is still novel enought to be worth pointing it out. Also notice that since 
both \mintinline{coq}{b} and  \mintinline{coq}{b'} had the same type we could specify it under the 
same set of parenthesis.

\mintinline{coq}{Inductive} definitions are also allowed to be recursive, as long as Coq is able to 
prove that this recursion comes to an end. In general this means that at least one constructor is not 
recursive. For example, here is the definition of Peano natural numbers in Coq.

\begin{minted}{coq}
Inductive nat :=
  | O 
  | S (n: nat).
\end{minted}

You can also define recursive functions, but not through the \mintinline{coq}{Definition} command. We 
use the \mintinline{coq}{Fixpoint} command instead. When using \mintinline{coq}{match} over a type 
with arguments in its constructors, it can be useful to use an identifier instead of a value in order 
to bind the value to the identifier. Observe how this is used in the following definition of addition
for Peano's natural numbers.

\begin{minted}{coq}
Fixpoint add (n m: nat) :=
  match n with
  | O => m
  | S n' => add n' (S m)
  end.
\end{minted}

If the argument itself will not be used, you can also use the special
identifier \mintinline{coq}{_} to discard it, like it's used in the following example 
of the function \mintinline{coq}{is_zero}.

\begin{minted}{coq}
Fixpoint is_zero(n: nat): bool :=
  match n with
  | O => true
  | _ => false
  end.
\end{minted}


\mintinline{coq}{Fixpoint} functions in Coq also have the catch that Coq must be able to ensure that
they are terminating. Therefore, a function that loops infinitely cannot be defined in Coq. 

% TODO: Simply let the command fail
% To show this, we use the \mintinline{coq}{Fail} command, which takes another command and succeeds if it fails. It also
% shows the reason why it failed.
\begin{minted}{coq}
Fixpoint loop (n: nat): nat := loop n.
\end{minted}
\vspace{-\baselineskip*3/2}
\begin{minted}[bgcolor=outputbg]{coq}
Recursive definition of loop is ill-formed.
In environment
loop : nat -> nat
n : nat
Recursive call to loop has principal argument equal to 
"n" instead of a subterm of "n".
Recursive definition is: "fun n : nat => loop n".
\end{minted}

These are the basic building blocks of Coq's programming language. There are not any built-in data 
types commonly found in other languages like booleans or numbers. These are instead defined as part of 
the standard library, in \mintinline{coq}{Coq.Bool.Bool} and \mintinline{coq}{Coq.Init.Nat}. Common 
expressions such as the \mintinline{coq}{if} expression are actually just syntactic sugar over the
\mintinline{coq}{match} expression. The same is true for a \mintinline{coq}{let ... in} expression, 
which lets you bind an expression to a variable and use it in another expression.
\begin{minted}{coq}
let x := 10 in x + 1
\end{minted}
\noindent In Coq, this statement desugars to a \mintinline{coq}{match} expression.
\begin{minted}{coq}
match 10 with
| x => x + 1
end
\end{minted}

To let Coq know that we want to use the definitions for \mintinline{coq}{bool} and 
\mintinline{coq}{nat} defined in its standard library, we would use the following commands.

\begin{minted}{coq}
From Coq Require Import Bool.Bool.
From Coq Require Import Init.Nat.
\end{minted}

Besides including the definitions mentioned before, the standard library also defines some
common functions, such as addition, and provide some syntactic sugar to work with them. For example, 
the two following statements are equivalent since they make use of the same function.

\begin{minted}{coq}
Compute add 1 2.
\end{minted}
\vspace{-\baselineskip*3/2}
\begin{minted}[bgcolor=outputbg]{coq}
= 3
     : nat
\end{minted}
\vspace{-\baselineskip*3/2}
\begin{minted}{coq}
Compute 1 + 2.
\end{minted}
\vspace{-\baselineskip*3/2}
\begin{minted}[bgcolor=outputbg]{coq}
= 3
     : nat
\end{minted}

To show the syntactic sugar that Coq is currently aware of you can use the following command. 

\begin{minted}{coq}
Print Visibility.
\end{minted}
\vspace{-\baselineskip*5/4}
\begin{minted}[bgcolor=outputbg]{coq}
...
Visible in scope nat_scope
"x >= y" := (ge x y)
"x > y" := (gt x y)
"x <= y <= z" := (and (le x y) (le y z))
"x <= y < z" := (and (le x y) (lt y z))
"n <= m" := (le n m)
"x < y <= z" := (and (lt x y) (le y z))
"x < y < z" := (and (lt x y) (lt y z))
"x < y" := (lt x y)
"x - y" := (Nat.sub x y)
"x + y" := (Nat.add x y)
"x * y" := (Nat.mul x y)
\end{minted}

One thing to point out from the output of this command is the fact that boolean equality of two numbers,
recognized as the function \mintinline{coq}{eqb}, is not expressed as \mintinline{coq}{==} or 
\mintinline{coq}{=} but with the\mintinline{coq}{=?} symbol. This is to highlight that this operator returns a boolean
value, since unlike other programming languages, booleans are not built-in into the language. Furthermore,
the \mintinline{coq}{=} operator is reserved for some other purpose in Coq.



\subsection{Coq as a theorem prover}
\label{sect:coq-proof-assistant}
\definecolor{goalbg}{rgb}{0.98,0.95,0.95}

% TODO: Talk about hypothesis and thesis

Besides the commands that allow you to interface with the programming language, Coq also offers commands
with which you can define theorems and prove them. In fact, the commands \mintinline{coq}{Theorem}, 
\mintinline{coq}{Lemma} and \mintinline{coq}{Example}, the main way in which you interact with the 
theorem proving side of Coq, are all equivalent with one another. The different names are simply for the 
developers to classify the properties they are trying to prove as they see fit.

Consider the following proposition. Pay attention to how we now use the \mintinline{coq}{:} symbol to separate the 
proposition with its name instead of the \mintinline{coq}{:=} symbol as we did in the programming language.

\begin{minted}{coq}
Example true_is_true : true = true.
\end{minted}

The proposition appears after the first \mintinline{coq}{:}, and it follows a similar syntax to 
expressions. % Warning 1 of Cury-Howard correspondance
After this command is executed Coq registers the proposition you want to prove and awaits for you
to provide a proof of this proposition. We do this by entering proof mode using the 
\mintinline{coq}{Proof} command.

In proof mode, Coq shows you the proposition you have to prove as a goal. In graphical interfaces this
is usually the proposition which appears under the horizontal line.

\begin{minted}[bgcolor=goalbg]{coq}
1 subgoal


========================= (1 / 1)

true = true
\end{minted}

The space above the horizontal line is reserved for local definitions, which are definitions that can
only be accessed from within the proof. Most of the time these definitions refer to our hypothesis. There
are no hypothesis at the moment, which is why the only text above the horizontal line is the goal counter.
The goal is the current proposition we need to prove. There can be more than one goal to prove in a proof,
and we say that the proof has concluded when there are no goals left.

Inside proof mode, a new set of commands a syntax are available to us to construct the proof. These are
called \emph{tactics}. For example, to prove the goal \mintinline{coq}{true = true} we wouldd use the 
\mintinline{coq}{reflexivity} tactic, which concludes an equality if both sides are syntactically the same. This is
exactly the case for this goal, which has \mintinline{coq}{true} on both sides.

Once the goal has been proven you can exit proof mode using the \mintinline{coq}{Qed} command. Therefore,
a theorem and its proof would look like this

\begin{figure}[!ht]
\begin{minted}{coq}
Example true_is_true : true = true.
Proof.
  reflexivity.
Qed.
\end{minted}
\label{lst:true-is-true}
\end{figure}

This example is not terribly exciting. In general we are more interested if we can prove a property for a
bigger set of values, not just one. To achieve this in Coq we use the \mintinline{coq}{forall} 
keyword, which has a similar syntax to that of function application.
% Warning 2 of Cury-Howard correspondance

\begin{figure}[!ht]
\begin{minted}{coq}
Example bool_refl' : forall b : bool, b = b.
\end{minted}
\label{lst:bool-eq-refl}
\end{figure}

If we enter proof mode, the goal is now \mintinline{coq}{forall b : bool, b = b}. We cannot conclude this
proof with \mintinline{coq}{reflexivity}, since the goal is not an equality, it has a quantifier 
beforehand. What we would like to say is that the proof is the same regardless of our choice of 
\mintinline{coq}{b}. In Coq we express this by introducing an arbitrary value \mintinline{coq}{b} and
proving the theorem for that \mintinline{coq}{b}. This is done through the \mintinline{coq}{intros} 
tactic.

\begin{minted}{coq}
Proof.
  intros b.
  reflexivity.
Qed.
\end{minted}

Proving something for all elements of a type is pretty powerful, but usually we are only interested in
proving things for elements which satisfy certain properties. To do this we make use of implication,
written with the \mintinline{coq}{->} symbol.
\begin{figure}[!ht]
\begin{minted}{coq}
Example bool_eq_sym' : forall b b' : bool, b = b' -> b' = b.
\end{minted}
\label{lst:bool-eq-sym}
\end{figure}

To start the proof we introduce the variables \mintinline{coq}{b} and \mintinline{coq}{b'} with 
\mintinline{coq}{intros} as before. This leaves us in the following state.

\begin{minted}[bgcolor=goalbg]{coq}
1 subgoal

b, b' : bool

========================= (1 / 1)

b = b' -> b' = b
\end{minted}

To proceed, we use \mintinline{coq}{intros} again, and we give the new constraint the name \mintinline{coq}{eq_b_b'}
to reflect its meaning

\begin{minted}[bgcolor=goalbg]{coq}
1 subgoal

b, b' : bool
eq_b_b' : b = b'

========================= (1 / 1)

b' = b
\end{minted}

What we have introduced this time under the name \mintinline{coq}{eq_b_b'} is not a value, but the
evidence that the proposition \mintinline{coq}{eq_b_b'} is true. We can later use that evidence with
other tactics, like \mintinline{coq}{rewrite}, which takes an equality and rewrites all appearances of
the expression on the left side of the \mintinline{coq}{=} symbol with that on the right side of the 
equality.

\begin{minted}[bgcolor=goalbg]{coq}
1 subgoal

b, b' : bool
eq_b_b' : b = b'

========================= (1 / 1)

b' = b'
\end{minted}

At this point we can conclude the proof with the \mintinline{coq}{reflexivity} tactic.

\begin{minted}{coq}
Example bool_eq_sym' : forall b b' : bool, b = b' -> b' = b.
Proof.
  intros b b'.
  intros eq_b_b'.
  rewrite eq_b_b'.
  reflexivity.
Qed.
\end{minted}

The dual of the universal quantifier \mintinline{coq}{forall} is the existential quantifier
\mintinline{coq}{exists}, which states that there is a value of one type which satisfies the specified
proposition.

\begin{minted}{coq}
Example has_zero : exists n: nat, n = 0.
\end{minted}

When proving a goal with an \mintinline{coq}{exists}, Coq expects you to provide a value with the 
equally-named \mintinline{coq}{exists} tactic, and show that the property holds for the given value.

\begin{minted}{coq}
Proof.
  (* Goal is [exists n : nat, n = 0.] *)
  exists 0. 
  (* Goal is [0 = 0.] *)
  reflexivity.
Qed.
\end{minted}

% However, in mathematics this is not the only approach to prove these kinds of theorems. It is also common
% to use \emph{reductio ad absurdum}, by attempting to prove that the proposition is false and failing to
% do so. However, this type of reasoning is not allowed in Coq, since it is not constructive. That is, if
% Coq allowed these types of arguments we could prove the existence of elements which followed one 
% property, but be unable 

In these proofs so far, we have treated all elements of a type the same way, not making a distinction on
how they were constructed. However, for some proofs it is necessary to make this distinction.

\begin{minted}{coq}
Theorem negb_involutive : forall b : bool, negb (negb b) = b.
\end{minted}

To prove this statement, we need to show that it holds true for both \mintinline{coq}{true} and 
\mintinline{coq}{false}. To do so we use the \mintinline{coq}{destruct} tactic, which takes a term as
an argument and creates as many subgoals as constructors it has. In each of these subgoals, the term
has been replaced by one of its constructors. Therefore, \mintinline{coq}{destruct} allows us to prove
that a proposition is true depending on how the term was constructed.

In this case, the first subgoal asks us to proof the following \mintinline{coq}{negb (negb true) = true}.
We can use the \mintinline{coq}{simpl} tactic to ask Coq to simplify the goal, for example by executing
the \mintinline{coq}{negb} function through its definition. This leaves us with 
\mintinline{coq}{true = true}, which we can prove through the \mintinline{coq}{reflexivity} tactic. The
same argument holds for the second subgoal

\begin{minted}{coq}
Proof.
  intros b. destruct b.
  - simpl.
    reflexivity.
  - simpl.
    reflexivity. 
Qed.
\end{minted}

As a matter of fact, the \mintinline{coq}{true = true} goal is something we already proved in the
\hyperref[lst:true-is-true]{\mintinline{coq}{true_is_true}} example before. We could reuse this proof
by using the \mintinline{coq}{apply} tactic instead, which receives the name of a proposition previously
defined and attempts to fit it into the current goal, by trying to infer the values of quantified 
variables. For example, we could have also used the 
\hyperref[lst:bool-eq-refl]{\mintinline{coq}{bool_eq_refl'}} theorem, and Coq would have set the value of
\mintinline{coq}{b} to \mintinline{coq}{true}.

The \mintinline{coq}{apply} tactic also works if the proposition to apply is part of an implication.
If we have a lemma \mintinline{coq}{h: P -> Q} and we need to prove \mintinline{coq}{Q}, we can use
\mintinline{coq}{apply h}, which will change the goal to \mintinline{coq}{P}, since if we are able to
prove \mintinline{coq}{P} then we can prove \mintinline{coq}{Q} by using \mintinline{coq}{h}. An example
of such a situation would be using the previously defined 
\hyperref[lst:bool-eq-sym]{\mintinline{coq}{bool_eq_sym'}}.

\begin{minted}{coq}
Lemma  h': forall b: bool, b = true -> true = b.
Proof.
  intros b b_true.
  (* Goal is [true = b] *)
  apply bool_eq_sym'.
  (* Goal is [b = true] *)
  apply b_true.
Qed.
\end{minted}

Notice how we conclude this example by applying a proof which lives as a local definition. The apply 
tactic is not restricted to the theorems available to Coq, but also to those arising from the context
of the proof.

Negation in Coq is not a first-class feature, but it is implemented in terms of implication and 
\mintinline{coq}{False}. The \mintinline{coq}{False} proposition represents a proposition which cannot be
proven, its dual is the \mintinline{coq}{True} proposition, for which there is one trivial proof called
\mintinline{coq}{I}.

Then, the negation of a proposition \mintinline{coq}{P}, written as \mintinline{coq}{~ P}, is defined as
\mintinline{coq}{P -> False}. The idea behind it is that if having a proof of \mintinline{coq}{P} allows
you to derive a proof of \mintinline{coq}{False} then you could not derive a proof for \mintinline{coq}{P}
in the first place, since there is no proof for \mintinline{coq}{P}.

The same way we have \mintinline{coq}{reflexivity} to end a proof if the goal is an equality and both
sides of the equality are constructed with the same constructors, the \mintinline{coq}{discriminate}
tactic allows us to end a proof if given one hypothesis of an equality which can be shown to be false
since both sides use different constructors.

For instance, consider the following proposition.
\begin{minted}{coq}
Example one_not_zero : ~ (1 = 0).
Proof.
  unfold not. (* Transforms [~ (1 = 0)] into [(1 = 0) -> False] *)
  intros h.   (* Introduces hypothesis [h: 1 = 0] *)
  discriminate h. (* Concludes that hypothesis h cannot be obtained *)
Qed.
\end{minted}

We've defined \mintinline{coq}{~ P} to be \mintinline{coq}{P -> False}. If we revert the terms in that implication we have
\mintinline{coq}{False -> P} which is trivially true for any proposition \mintinline{coq}{P}. This fact is known in the literature
as the principle of explosion or \emph{ex falso quodlibet}. In Coq this principle shows in some proofs
where instead of proving the goal it may be convenient that with the assumed hypothesis we can derive
a proof for false. This principle is accessed through the \mintinline{coq}{exfalso} tactic.

\begin{minted}{coq}
Theorem not_true_is_false' : forall b : bool,
  ~ (b = true) → b = false.
Proof.
  intros b not_b_true.
  destruct b.
  - (* b = true *)
    unfold not in not_b_true.
    exfalso.
    apply not_b_true.
    reflexivity.
  - (* b = false *) 
    reflexivity.
Qed.
\end{minted}

Besides negating a proposition, Coq also allows us to use the usual logical connectives. And is expressed 
with the symbol \mintinline{coq}{/\ } and or with the symbol \mintinline{coq}{\/}, mimicking their shape's 
in mathematical notation: $\wedge$ and $\vee$.

When dealing with \mintinline{coq}{/\ } in the goal, we can use the \mintinline{coq}{split} tactic to
divide the goal into two, which we'll have to prove separately. If the \mintinline{coq}{/\} is instead
in a hypothesis \mintinline{coq}{h}, we can use the \mintinline{coq}{destruct h} tactic, which would 
separate both sides of the conjunction in different hypothesis. Coq will try to give appropriate names
to the new hypothesis, but most of the time it's a better idea to give the names on your own. To do so,
you can use \mintinline{coq}{destruct h as [hl hr]}, where \mintinline{coq}{hl} and \mintinline{coq}{hr}
are the names given to the left and right sides of the conjunction respectively.

When dealing with \mintinline{coq}{\/} in the goal, we need to decide which part of the proposition we'd
like to prove in order to prove the hypothesis. To choose the left side of the disjunction we use the
appropriately named \mintinline{coq}{left} tactic, with the \mintinline{coq}{right} tactic choosing the
right side of the disjunction as expected. If the \mintinline{coq}{\/} is instead in a hypothesis 
\mintinline{coq}{h}, we can again use the \mintinline{coq}{destruct h} tactic, which will ask us to
prove the same goal twice: once with the left side of the disjunction \mintinline{coq}{h} and once with
the right side of the disjunction \mintinline{coq}{h}. In both of these options the sides of the 
disjunction would replace the \mintinline{coq}{h} hypothesis, but it's also possible to rename them 
by employing the tactic as \mintinline{coq}{destruct h as [hl | hr]}, where \mintinline{coq}{hl} and
\mintinline{coq}{hr} are again the names of the left and right side of the disjunction respectively.

Before moving on to the next topic, I wanted to point out a particularity of Coq's mathematical
foundations. Notice that when handling a goal of type $P \vee Q$ we need to know which between $P$ or $Q$
holds before proceeding with the proof. This is due to Coq's logic being constructive. In a 
non-constructive logic proving that a proposition cannot be false is equivalent to proving that that
proposition is true. In a constructive logic, however, a proposition is only true if you show it to be
true. While nuanced, this is a powerful distinction.

Consider the following proposition:
\begin{center}
There exist irrational numbers $a$ and $b$ such that $a^b$ is rational.
\end{center}
In classical logic, a proof of the previous would proceed like this. We assume we have already proven that
$\sqrt{2}$ is irrational. Then consider whether $\sqrt{2}^{\sqrt{2}}$ is rational. If it is, we can conclude
the proof with $a = b = \sqrt{2}$. Otherwise $\sqrt{2}^{\sqrt{2}}$ is irrational. We choose $a = \sqrt{2}^
{\sqrt{2}}$ and $b = \sqrt{2}$. Then
$$
a^b = \left(\sqrt{2}^{\sqrt{2}}\right)^{\sqrt{2}} = \sqrt{2}^{\sqrt{2}\sqrt{2}} = \sqrt{2} ^ 2 = 2
$$
\noindent Since $2$ is rational this concludes the proof.

Notice how we've concluded the proof without knowing the values of $a$ and $b$. This happened because we
were able to assume the following: 
\begin{center}
$\sqrt{2}^{\sqrt{2}}$ is rational ${\Large{\vee}} \sqrt{2}^{\sqrt{2}}$ is  irrational.
\end{center}
\noindent A constructive logic has the advantage that, if something is proven within it, you are 
guaranteed to have values for what was proven. Nevertheless, sometimes proofs require of the 
\mintinline{coq}{excluded_middle}. For those cases, Coq offers \mintinline{coq}{excluded_middle}
as an Axiom in the module \mintinline{coq}{Coq.Logic.ClassicalFacts}. An axiom is a proposition
which Coq accepts as true without proof, and can be declared with the \mintinline{coq}{Axiom}
command. However, it is dangerous to do so, one may introduce a proposition which would enable 
proving \mintinline{coq}{true = false}. Fortunately, we can rely on Coq's provided assumptions to
not break the consistency of its logic.


\subsection{The Curry-Howard correspondence}
\label{sect:curry-howard}

In the field of programming languages and type theory, the Curry-Howard correspondence states that there
exists an isomorphism between programs and proofs, and types and propositions. So far we have treated Coq
the programming language and Coq the proof assistant as two different things, but in fact, they are the 
same. Whenever we wrote \mintinline{coq}{Example} or \mintinline{coq}{Theorem}, we could have used
\mintinline{coq}{Definition} instead!

\begin{minted}{coq}
Definition true_is_true' : true = true.
Proof.
  reflexivity.
Qed.
\end{minted}

The type of \mintinline{coq}{true_is_true} is in fact the proposition we are trying to prove, and its 
value is the proof built in proof mode. In fact, not even proof mode was necessary. We could have 
specified the ``proof object'' directly after the \mintinline{coq}{:=} symbol. This is made apparent if we
ask Coq to print one of our prior proofs.

\begin{minted}{coq}
Print has_zero. 
\end{minted}
\vspace{-\baselineskip}
\begin{minted}[bgcolor=outputbg]{coq}
has_zero = 
ex_intro (fun n : nat => n = 0) 0 eq_refl
     : exists n : nat, n = 0
\end{minted}


Here we see that we construct a proof value using the \mintinline{coq}{ex_intro} constructor, with the
following parameters:
\begin{itemize}
    \item \mintinline{coq}{fun n : nat => n = 0} is a function which takes a \mintinline{coq}{nat} and returns the proposition \mintinline{coq}{n = 0}
    \item 0 is the witness of the \mintinline{coq}{exists n : nat, n = 0}, that is, the value of \mintinline{coq}{n} for which the property is true
    \item \mintinline{coq}{eq_refl} is the proof that \mintinline{coq}{0 = 0}. This is what gets applied when we use the \mintinline{coq}{reflexivity} tactic!
\end{itemize}

The feature which allows us to use Coq as a theorem prover is its type system. In fact, Coq's type system
is not like those of other general purpose language, since it allows the definition of dependent types. A
dependent type is a type whose definition depends on a value. This allows us to make types such as 
\mintinline{coq}{Vector.t nat 10}, of all lists of length 10, or more importantly, since propositions are
types it allows us to refer to individual values in our propositions, instead of just types.

Dependent data types can be created with the \mintinline{coq}{Record} command.
\begin{minted}{coq}
Record dependent_example := {
  a: nat;
  proof_a_not_0: a <> 0
}.
\end{minted}
The \mintinline{coq}{dependent_example} type represents all pairs of naturals 
\mintinline{coq}{a} and
proofs that \mintinline{coq}{a} is not 0. We can generalize this example to define the subset of 
elements of a type $A$ which fulfill some condition $P$, that is $\{x \in A : P (x)\}$. This type of record is defined in Coq's standard
library and it is called \mintinline{coq}{sig}.

\begin{minted}{coq}
Print sig.
\end{minted}
\vspace{-\baselineskip*3/2}
\begin{minted}[bgcolor=outputbg]{coq}
Inductive sig (A : Type) (P : A -> Prop) : Type :=
    exist : forall x : A, P x -> {x : A | P x}.

Arguments sig [A]%type_scope P%type_scope
Arguments exist [A]%type_scope P%function_scope x _
\end{minted}
\noindent \mintinline{coq}{sig} is usually used through a special syntax also defined in the standard library
where \mintinline{coq}{{x : A | P x}} represents the type \mintinline{coq}{sig A P}.

The \mintinline{coq}{forall} keyword behaves like function application, with the difference that it
allows the return type to use the argument's value, that is, it allows the return type to depend on
the  function's parameters. Otherwise, \mintinline{coq}{forall n : nat, nat} is the same as
\mintinline{coq}{nat -> nat}, as can be seen in the following example.

\begin{minted}{coq}
Definition a : forall n: nat, nat := add 1.
Check a.
\end{minted}
\vspace{-\baselineskip*3/2}
\begin{minted}[bgcolor=outputbg]{coq}
a
     : nat -> nat
\end{minted}

The \mintinline{coq}{True} and \mintinline{coq}{False} properties are in fact defined with \mintinline{coq}{Inductive}. The definition of \mintinline{coq}{False} is equivalent to our previous definition of 
\hyperref[lst:void]{\mintinline{coq}{void}}, an inductive type with no constructors, and 
\mintinline{coq}{True} is an inductive type with one constructor, \mintinline{coq}{I}. Intuitively it 
makes sense, since there is not proof of falsehood, therefore it has no constructors, and you can always
prove \mintinline{coq}{True} without needing any extra information, hence the constructor without 
arguments.

Dependent types also allow us to achieve something similar to parametric polymorphism. Consider the
previously defined \mintinline{coq}{bool_identity function}. This function is a less powerful version
of the generic \mintinline{coq}{identity} function which works for arguments of any type. These types
of functions are defined in other functional programming languages through the use of parametric
polymorphism, making both the input and output types generic. However, since in Coq types are first
class values we don't need parametric polymorphism to define such a function.
\begin{minted}{coq}
Definition identity' (A: Type)(b: A) := b. 
Compute identity' bool true.
\end{minted}
This definition is possible since we are allowed to make the type of the second argument depend on the
value of the first with dependent types. However, using this identity function is noticeably less
ergonomic than its counterpart in other functional programming languages since we also need to 
explicitly specify the type of its argument. In other functional programming languages, this task is
left to the type checker through the feature of type inference. Instead, Coq introduces a more powerful
feature: implicit arguments. An explicit argument is defined by surrounding it with curly brackets instead of parenthesis.
\begin{minted}{coq}
Definition identity {A: Type}(b: A) := b. 
Compute identity true.
\end{minted}
Coq will attempt to derive the value for implicit arguments automatically, using globally available
information as well as its signature. You can also ask Coq to infer the value of a parameter which was
not marked as implicit by using the \mintinline{coq}{_} identifier instead of its value.
\begin{minted}{coq}
Compute identity' _ true.
\end{minted}
To provide all arguments of a function explicitly, even if they were defined as implicit, you can 
refer to the function with a prepended \mintinline{coq}{@}.
\begin{minted}{coq}
Compute @identity bool true.
\end{minted}
\noindent This is occasionally useful if Coq is struggling to infer the implicit argument\footnote{Coq's algorithm for type checking and type synthesis can be exponential in time in the worst case. See \cite{CoqTypeCheckingExponential} for more information.}.


In other programming languages, many commonly used functions are made available in the form of a
standard library. Coq does the same thing, with its standard library perhaps containing more basic
definitions than in most other functional programming languages since the booleans and integers are
delegated to it. For example, Coq's standard library defines the \mintinline{coq}{list} data type and
its constructors, and the usual operations over them such as \mintinline{coq}{map}, 
\mintinline{coq}{filter}, \mintinline{coq}{fold_left} and \mintinline{coq}{fold_right} or
\mintinline{coq}{forallb} and \mintinline{coq}{existsb}. These are defined in the
\mintinline{coq}{Coq.Lists.List} module.

\begin{minted}{coq}
Print existsb.
\end{minted}
\vspace{-\baselineskip*3/2}
\begin{minted}[bgcolor=outputbg]{coq}
existsb = 
fun (A : Type) (f : A -> bool) =>
fix existsb (l : list A) : bool :=
  match l with
  | nil => false
  | a :: l0 => f a || existsb l0
  end
     : forall A : Type, (A -> bool) -> list A -> bool
\end{minted}


However, besides providing data types and operations Coq also provides theorems which let us reason
about these data types and operations. For example, in \mintinline{coq}{Coq.Lists.List} the
\mintinline{coq}{existsb_exists} lemma is defined, which establishes the relationship between the
\mintinline{coq}{existsb} function and the \mintinline{coq}{exists} quantifier.

\begin{minted}{coq}
Print existsb.
\end{minted}
\vspace{-\baselineskip*3/2}
\begin{minted}[bgcolor=outputbg]{coq}
existsb_exists
     : forall (A : Type) (f : A -> bool) (l : list A),
       existsb f l = true <-> (exists x : A, In x l /\ f x = true)
\end{minted}

These lemmas are used extensively throughout this project, and they're also the reason why we try to
define things in terms of functions in the standard library whenever possible.